(function(){"use strict";try{if(typeof document<"u"){var a=document.createElement("style");a.appendChild(document.createTextNode(".mapdiv[data-v-289550ca]{width:100%;height:100%}.advanced-marker-wrapper{display:none}.mapdiv .advanced-marker-wrapper{display:inline-block}.custom-control-wrapper[data-v-ab9120cd]{display:none}.mapdiv .custom-control-wrapper[data-v-ab9120cd]{display:inline-block}.info-window-wrapper[data-v-f0c09f6e]{display:none}.mapdiv .info-window-wrapper[data-v-f0c09f6e]{display:inline-block}.custom-marker-wrapper[data-v-2d2d343a]{display:none}.mapdiv .custom-marker-wrapper[data-v-2d2d343a]{display:inline-block}")),document.head.appendChild(a)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})();
var it = Object.defineProperty;
var at = (n, e, t) => e in n ? it(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var pe = (n, e, t) => (at(n, typeof e != "symbol" ? e + "" : e, t), t);
import { defineComponent as P, ref as w, provide as G, watch as q, onMounted as Ye, onBeforeUnmount as B, markRaw as S, toRef as j, openBlock as V, createElementBlock as z, createElementVNode as le, renderSlot as W, normalizeProps as lt, guardReactiveProps as ut, computed as K, Comment as ye, inject as k, Fragment as ct, mergeProps as we, createCommentVNode as Ee } from "vue";
const D = Symbol("map"), Z = Symbol("api"), _e = Symbol("marker"), ke = Symbol("markerCluster"), ue = Symbol("CustomMarker"), Xe = Symbol("mapTilesLoaded"), H = [
  "click",
  "dblclick",
  "drag",
  "dragend",
  "dragstart",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "rightclick"
];
function dt(n, e, t, r) {
  function s(o) {
    return o instanceof t ? o : new t(function(i) {
      i(o);
    });
  }
  return new (t || (t = Promise))(function(o, i) {
    function l(d) {
      try {
        c(r.next(d));
      } catch (u) {
        i(u);
      }
    }
    function a(d) {
      try {
        c(r.throw(d));
      } catch (u) {
        i(u);
      }
    }
    function c(d) {
      d.done ? o(d.value) : s(d.value).then(l, a);
    }
    c((r = r.apply(n, e || [])).next());
  });
}
function pt(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var fe, Pe;
function ft() {
  return Pe || (Pe = 1, fe = function n(e, t) {
    if (e === t)
      return !0;
    if (e && t && typeof e == "object" && typeof t == "object") {
      if (e.constructor !== t.constructor)
        return !1;
      var r, s, o;
      if (Array.isArray(e)) {
        if (r = e.length, r != t.length)
          return !1;
        for (s = r; s-- !== 0; )
          if (!n(e[s], t[s]))
            return !1;
        return !0;
      }
      if (e.constructor === RegExp)
        return e.source === t.source && e.flags === t.flags;
      if (e.valueOf !== Object.prototype.valueOf)
        return e.valueOf() === t.valueOf();
      if (e.toString !== Object.prototype.toString)
        return e.toString() === t.toString();
      if (o = Object.keys(e), r = o.length, r !== Object.keys(t).length)
        return !1;
      for (s = r; s-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(t, o[s]))
          return !1;
      for (s = r; s-- !== 0; ) {
        var i = o[s];
        if (!n(e[i], t[i]))
          return !1;
      }
      return !0;
    }
    return e !== e && t !== t;
  }), fe;
}
var ht = ft(), mt = /* @__PURE__ */ pt(ht);
const qe = "__googleMapsScriptId";
var U;
(function(n) {
  n[n.INITIALIZED = 0] = "INITIALIZED", n[n.LOADING = 1] = "LOADING", n[n.SUCCESS = 2] = "SUCCESS", n[n.FAILURE = 3] = "FAILURE";
})(U || (U = {}));
class N {
  /**
   * Creates an instance of Loader using [[LoaderOptions]]. No defaults are set
   * using this library, instead the defaults are set by the Google Maps
   * JavaScript API server.
   *
   * ```
   * const loader = Loader({apiKey, version: 'weekly', libraries: ['places']});
   * ```
   */
  constructor({ apiKey: e, authReferrerPolicy: t, channel: r, client: s, id: o = qe, language: i, libraries: l = [], mapIds: a, nonce: c, region: d, retries: u = 3, url: h = "https://maps.googleapis.com/maps/api/js", version: m }) {
    if (this.callbacks = [], this.done = !1, this.loading = !1, this.errors = [], this.apiKey = e, this.authReferrerPolicy = t, this.channel = r, this.client = s, this.id = o || qe, this.language = i, this.libraries = l, this.mapIds = a, this.nonce = c, this.region = d, this.retries = u, this.url = h, this.version = m, N.instance) {
      if (!mt(this.options, N.instance.options))
        throw new Error(`Loader must not be called again with different options. ${JSON.stringify(this.options)} !== ${JSON.stringify(N.instance.options)}`);
      return N.instance;
    }
    N.instance = this;
  }
  get options() {
    return {
      version: this.version,
      apiKey: this.apiKey,
      channel: this.channel,
      client: this.client,
      id: this.id,
      libraries: this.libraries,
      language: this.language,
      region: this.region,
      mapIds: this.mapIds,
      nonce: this.nonce,
      url: this.url,
      authReferrerPolicy: this.authReferrerPolicy
    };
  }
  get status() {
    return this.errors.length ? U.FAILURE : this.done ? U.SUCCESS : this.loading ? U.LOADING : U.INITIALIZED;
  }
  get failed() {
    return this.done && !this.loading && this.errors.length >= this.retries + 1;
  }
  /**
   * CreateUrl returns the Google Maps JavaScript API script url given the [[LoaderOptions]].
   *
   * @ignore
   * @deprecated
   */
  createUrl() {
    let e = this.url;
    return e += "?callback=__googleMapsCallback&loading=async", this.apiKey && (e += `&key=${this.apiKey}`), this.channel && (e += `&channel=${this.channel}`), this.client && (e += `&client=${this.client}`), this.libraries.length > 0 && (e += `&libraries=${this.libraries.join(",")}`), this.language && (e += `&language=${this.language}`), this.region && (e += `&region=${this.region}`), this.version && (e += `&v=${this.version}`), this.mapIds && (e += `&map_ids=${this.mapIds.join(",")}`), this.authReferrerPolicy && (e += `&auth_referrer_policy=${this.authReferrerPolicy}`), e;
  }
  deleteScript() {
    const e = document.getElementById(this.id);
    e && e.remove();
  }
  /**
   * Load the Google Maps JavaScript API script and return a Promise.
   * @deprecated, use importLibrary() instead.
   */
  load() {
    return this.loadPromise();
  }
  /**
   * Load the Google Maps JavaScript API script and return a Promise.
   *
   * @ignore
   * @deprecated, use importLibrary() instead.
   */
  loadPromise() {
    return new Promise((e, t) => {
      this.loadCallback((r) => {
        r ? t(r.error) : e(window.google);
      });
    });
  }
  importLibrary(e) {
    return this.execute(), google.maps.importLibrary(e);
  }
  /**
   * Load the Google Maps JavaScript API script with a callback.
   * @deprecated, use importLibrary() instead.
   */
  loadCallback(e) {
    this.callbacks.push(e), this.execute();
  }
  /**
   * Set the script on document.
   */
  setScript() {
    var e, t;
    if (document.getElementById(this.id)) {
      this.callback();
      return;
    }
    const r = {
      key: this.apiKey,
      channel: this.channel,
      client: this.client,
      libraries: this.libraries.length && this.libraries,
      v: this.version,
      mapIds: this.mapIds,
      language: this.language,
      region: this.region,
      authReferrerPolicy: this.authReferrerPolicy
    };
    Object.keys(r).forEach(
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (o) => !r[o] && delete r[o]
    ), !((t = (e = window == null ? void 0 : window.google) === null || e === void 0 ? void 0 : e.maps) === null || t === void 0) && t.importLibrary || ((o) => {
      let i, l, a, c = "The Google Maps JavaScript API", d = "google", u = "importLibrary", h = "__ib__", m = document, p = window;
      p = p[d] || (p[d] = {});
      const f = p.maps || (p.maps = {}), g = /* @__PURE__ */ new Set(), v = new URLSearchParams(), E = () => (
        // @ts-ignore
        i || (i = new Promise((y, M) => dt(this, void 0, void 0, function* () {
          var O;
          yield l = m.createElement("script"), l.id = this.id, v.set("libraries", [...g] + "");
          for (a in o)
            v.set(a.replace(/[A-Z]/g, (b) => "_" + b[0].toLowerCase()), o[a]);
          v.set("callback", d + ".maps." + h), l.src = this.url + "?" + v, f[h] = y, l.onerror = () => i = M(Error(c + " could not load.")), l.nonce = this.nonce || ((O = m.querySelector("script[nonce]")) === null || O === void 0 ? void 0 : O.nonce) || "", m.head.append(l);
        })))
      );
      f[u] ? console.warn(c + " only loads once. Ignoring:", o) : f[u] = (y, ...M) => g.add(y) && E().then(() => f[u](y, ...M));
    })(r);
    const s = this.libraries.map((o) => this.importLibrary(o));
    s.length || s.push(this.importLibrary("core")), Promise.all(s).then(() => this.callback(), (o) => {
      const i = new ErrorEvent("error", { error: o });
      this.loadErrorCallback(i);
    });
  }
  /**
   * Reset the loader state.
   */
  reset() {
    this.deleteScript(), this.done = !1, this.loading = !1, this.errors = [], this.onerrorEvent = null;
  }
  resetIfRetryingFailed() {
    this.failed && this.reset();
  }
  loadErrorCallback(e) {
    if (this.errors.push(e), this.errors.length <= this.retries) {
      const t = this.errors.length * Math.pow(2, this.errors.length);
      console.error(`Failed to load Google Maps script, retrying in ${t} ms.`), setTimeout(() => {
        this.deleteScript(), this.setScript();
      }, t);
    } else
      this.onerrorEvent = e, this.callback();
  }
  callback() {
    this.done = !0, this.loading = !1, this.callbacks.forEach((e) => {
      e(this.onerrorEvent);
    }), this.callbacks = [];
  }
  execute() {
    if (this.resetIfRetryingFailed(), !this.loading)
      if (this.done)
        this.callback();
      else {
        if (window.google && window.google.maps && window.google.maps.version) {
          console.warn("Google Maps already loaded outside @googlemaps/js-api-loader. This may result in undesirable behavior as options and script parameters may not match."), this.callback();
          return;
        }
        this.loading = !0, this.setScript();
      }
  }
}
function gt(n) {
  return class extends n.OverlayView {
    constructor(r) {
      super();
      pe(this, "element");
      pe(this, "opts");
      const { element: s, ...o } = r;
      this.element = s, this.opts = o, this.opts.map && this.setMap(this.opts.map);
    }
    getPosition() {
      return this.opts.position ? this.opts.position instanceof n.LatLng ? this.opts.position : new n.LatLng(this.opts.position) : null;
    }
    getVisible() {
      if (!this.element)
        return !1;
      const r = this.element;
      return r.style.display !== "none" && r.style.visibility !== "hidden" && (r.style.opacity === "" || Number(r.style.opacity) > 0.01);
    }
    onAdd() {
      if (!this.element)
        return;
      const r = this.getPanes();
      r && r.overlayMouseTarget.appendChild(this.element);
    }
    draw() {
      if (!this.element)
        return;
      const r = this.getProjection(), s = r == null ? void 0 : r.fromLatLngToDivPixel(this.getPosition());
      if (s) {
        this.element.style.position = "absolute";
        let o, i;
        switch (this.opts.anchorPoint) {
          case "TOP_CENTER":
            o = "-50%", i = "-100%";
            break;
          case "BOTTOM_CENTER":
            o = "-50%", i = "0";
            break;
          case "LEFT_CENTER":
            o = "-100%", i = "-50%";
            break;
          case "RIGHT_CENTER":
            o = "0", i = "-50%";
            break;
          case "TOP_LEFT":
            o = "-100%", i = "-100%";
            break;
          case "TOP_RIGHT":
            o = "0", i = "-100%";
            break;
          case "BOTTOM_LEFT":
            o = "-100%", i = "0";
            break;
          case "BOTTOM_RIGHT":
            o = "0", i = "0";
            break;
          default:
            o = "-50%", i = "-50%";
        }
        const l = s.x + (this.opts.offsetX || 0) + "px", a = s.y + (this.opts.offsetY || 0) + "px";
        this.element.style.transform = `translateX(${o}) translateX(${l}) translateY(${i}) translateY(${a})`, this.opts.zIndex && (this.element.style.zIndex = this.opts.zIndex.toString());
      }
    }
    onRemove() {
      this.element && this.element.remove();
    }
    setOptions(r) {
      const { element: s, ...o } = r;
      this.element = s, this.opts = o, this.draw();
    }
  };
}
let Se;
const Ae = [
  "bounds_changed",
  "center_changed",
  "click",
  "contextmenu",
  "dblclick",
  "drag",
  "dragend",
  "dragstart",
  "heading_changed",
  "idle",
  "isfractionalzoomenabled_changed",
  "mapcapabilities_changed",
  "maptypeid_changed",
  "mousemove",
  "mouseout",
  "mouseover",
  "projection_changed",
  "renderingtype_changed",
  "rightclick",
  "tilesloaded",
  "tilt_changed",
  "zoom_changed"
], vt = P({
  props: {
    apiPromise: {
      type: Promise
    },
    apiKey: {
      type: String,
      default: ""
    },
    version: {
      type: String,
      default: "weekly"
    },
    libraries: {
      type: Array,
      default: () => ["places", "marker"]
    },
    region: {
      type: String,
      required: !1
    },
    language: {
      type: String,
      required: !1
    },
    backgroundColor: {
      type: String,
      required: !1
    },
    center: {
      type: Object,
      default: () => ({ lat: 0, lng: 0 })
    },
    clickableIcons: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    colorScheme: {
      type: String,
      required: !1
    },
    controlSize: {
      type: Number,
      required: !1
    },
    disableDefaultUi: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    disableDoubleClickZoom: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    draggable: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    draggableCursor: {
      type: String,
      required: !1
    },
    draggingCursor: {
      type: String,
      required: !1
    },
    fullscreenControl: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    fullscreenControlPosition: {
      type: String,
      required: !1
    },
    gestureHandling: {
      type: String,
      required: !1
    },
    heading: {
      type: Number,
      required: !1
    },
    isFractionalZoomEnabled: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    keyboardShortcuts: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    mapTypeControl: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    mapTypeControlOptions: {
      type: Object,
      required: !1
    },
    mapTypeId: {
      type: [Number, String],
      required: !1
    },
    mapId: {
      type: String,
      required: !1
    },
    maxZoom: {
      type: Number,
      required: !1
    },
    minZoom: {
      type: Number,
      required: !1
    },
    noClear: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    panControl: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    panControlPosition: {
      type: String,
      required: !1
    },
    restriction: {
      type: Object,
      required: !1
    },
    rotateControl: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    rotateControlPosition: {
      type: String,
      required: !1
    },
    scaleControl: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    scaleControlStyle: {
      type: Number,
      required: !1
    },
    scrollwheel: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    streetView: {
      type: Object,
      required: !1
    },
    streetViewControl: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    streetViewControlPosition: {
      type: String,
      required: !1
    },
    styles: {
      type: Array,
      required: !1
    },
    tilt: {
      type: Number,
      required: !1
    },
    zoom: {
      type: Number,
      required: !1
    },
    zoomControl: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    zoomControlPosition: {
      type: String,
      required: !1
    },
    cameraControl: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    cameraControlPosition: {
      type: String,
      required: !1
    },
    nonce: {
      type: String,
      default: ""
    }
  },
  emits: Ae,
  setup(n, { emit: e }) {
    const t = w(), r = w(!1), s = w(), o = w(), i = w(!1);
    G(D, s), G(Z, o), G(Xe, i);
    const l = () => {
      const u = { ...n };
      Object.keys(u).forEach((f) => {
        u[f] === void 0 && delete u[f];
      });
      const m = (f) => {
        var g;
        return f ? { position: (g = o.value) == null ? void 0 : g.ControlPosition[f] } : {};
      }, p = {
        scaleControlOptions: n.scaleControlStyle ? { style: n.scaleControlStyle } : {},
        panControlOptions: m(n.panControlPosition),
        zoomControlOptions: m(n.zoomControlPosition),
        rotateControlOptions: m(n.rotateControlPosition),
        streetViewControlOptions: m(n.streetViewControlPosition),
        fullscreenControlOptions: m(n.fullscreenControlPosition),
        cameraControlOptions: m(n.cameraControlPosition),
        disableDefaultUI: n.disableDefaultUi
      };
      return { ...u, ...p };
    }, a = q(
      [o, s],
      ([u, h]) => {
        const m = u, p = h;
        m && p && (m.event.addListenerOnce(p, "tilesloaded", () => {
          i.value = !0;
        }), setTimeout(a, 0));
      },
      { immediate: !0 }
    ), c = () => {
      try {
        const { apiKey: u, region: h, version: m, language: p, libraries: f, nonce: g } = n;
        Se = new N({ apiKey: u, region: h, version: m, language: p, libraries: f, nonce: g });
      } catch (u) {
        console.error(u);
      }
    }, d = (u) => {
      o.value = S(u.maps), s.value = S(new u.maps.Map(t.value, l()));
      const h = gt(o.value);
      o.value[ue] = h, Ae.forEach((p) => {
        var f;
        (f = s.value) == null || f.addListener(p, (g) => e(p, g));
      }), r.value = !0;
      const m = Object.keys(n).filter(
        (p) => !["apiPromise", "apiKey", "version", "libraries", "region", "language", "center", "zoom", "nonce"].includes(
          p
        )
      ).map((p) => j(n, p));
      q(
        [() => n.center, () => n.zoom, ...m],
        ([p, f], [g, v]) => {
          var b, C, T;
          const { center: E, zoom: y, ...M } = l();
          (b = s.value) == null || b.setOptions(M), f !== void 0 && f !== v && ((C = s.value) == null || C.setZoom(f));
          const O = !g || p.lng !== g.lng || p.lat !== g.lat;
          p && O && ((T = s.value) == null || T.panTo(p));
        }
      );
    };
    return Ye(() => {
      n.apiPromise && n.apiPromise instanceof Promise ? n.apiPromise.then(d) : (c(), Se.load().then(d));
    }), B(() => {
      var u;
      i.value = !1, s.value && ((u = o.value) == null || u.event.clearInstanceListeners(s.value));
    }), { mapRef: t, ready: r, map: s, api: o, mapTilesLoaded: i };
  }
});
const re = (n, e) => {
  const t = n.__vccOpts || n;
  for (const [r, s] of e)
    t[r] = s;
  return t;
}, yt = {
  ref: "mapRef",
  class: "mapdiv"
};
function wt(n, e, t, r, s, o) {
  return V(), z("div", null, [
    le("div", yt, null, 512),
    W(n.$slots, "default", lt(ut({ ready: n.ready, map: n.map, api: n.api, mapTilesLoaded: n.mapTilesLoaded })), void 0, !0)
  ]);
}
const Ir = /* @__PURE__ */ re(vt, [["render", wt], ["__scopeId", "data-v-289550ca"]]);
function Et(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var _t = function n(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor !== t.constructor)
      return !1;
    var r, s, o;
    if (Array.isArray(e)) {
      if (r = e.length, r != t.length)
        return !1;
      for (s = r; s-- !== 0; )
        if (!n(e[s], t[s]))
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === t.source && e.flags === t.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === t.toString();
    if (o = Object.keys(e), r = o.length, r !== Object.keys(t).length)
      return !1;
    for (s = r; s-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, o[s]))
        return !1;
    for (s = r; s-- !== 0; ) {
      var i = o[s];
      if (!n(e[i], t[i]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
};
const ee = /* @__PURE__ */ Et(_t), Te = ["click", "drag", "dragend", "dragstart", "gmp-click"], kt = P({
  name: "AdvancedMarker",
  props: {
    options: {
      type: Object,
      required: !0
    },
    pinOptions: {
      type: Object,
      required: !1
    }
  },
  emits: Te,
  setup(n, { emit: e, expose: t, slots: r }) {
    const s = w(), o = K(() => {
      var m;
      return (m = r.content) == null ? void 0 : m.call(r).some((p) => p.type !== ye);
    }), i = j(n, "options"), l = j(n, "pinOptions"), a = w(), c = k(D, w()), d = k(Z, w()), u = k(ke, w()), h = K(
      () => !!(u.value && d.value && a.value instanceof google.maps.marker.AdvancedMarkerElement)
    );
    return q(
      [c, i, l, s],
      async (m, [p, f, g, v]) => {
        var C, T, be;
        const E = !ee(i.value, f) || !ee(l.value, g), y = s.value !== v, M = E || y || c.value !== p;
        if (!c.value || !d.value || !M || o.value && !s.value)
          return;
        const { AdvancedMarkerElement: O, PinElement: b } = d.value.marker;
        if (a.value) {
          const { map: ce, content: ne, ...de } = i.value;
          Object.assign(a.value, {
            content: o.value ? s.value : l.value ? new b(l.value).element : ne,
            ...de
          }), h.value && ((C = u.value) == null || C.removeMarker(a.value), (T = u.value) == null || T.addMarker(a.value));
        } else
          o.value ? i.value.content = s.value : l.value && (i.value.content = new b(l.value).element), a.value = S(new O(i.value)), h.value ? (be = u.value) == null || be.addMarker(a.value) : a.value.map = c.value, Te.forEach((ce) => {
            var ne;
            (ne = a.value) == null || ne.addListener(ce, (de) => e(ce, de));
          });
      },
      {
        immediate: !0,
        flush: "post"
        // Ensure DOM updates happen before this watcher runs
      }
    ), B(() => {
      var m, p;
      a.value && ((m = d.value) == null || m.event.clearInstanceListeners(a.value), h.value ? (p = u.value) == null || p.removeMarker(a.value) : a.value.map = null);
    }), G(_e, a), t({ marker: a }), { hasCustomSlotContent: o, markerRef: s };
  }
});
const Ct = {
  key: 0,
  class: "advanced-marker-wrapper"
};
function Ot(n, e, t, r, s, o) {
  return V(), z(ct, null, [
    n.hasCustomSlotContent ? (V(), z("div", Ct, [
      le("div", we({ ref: "markerRef" }, n.$attrs), [
        W(n.$slots, "content")
      ], 16)
    ])) : Ee("", !0),
    W(n.$slots, "default")
  ], 64);
}
const jr = /* @__PURE__ */ re(kt, [["render", Ot]]), Le = (n) => n === "Marker", xe = (n) => n === ue, J = (n, e, t, r) => {
  const s = w(), o = k(D, w()), i = k(Z, w()), l = k(ke, w()), a = K(
    () => !!(l.value && i.value && (s.value instanceof i.value.Marker || s.value instanceof i.value[ue]))
  );
  return q(
    [o, t],
    (c, [d, u]) => {
      var m, p, f;
      const h = !ee(t.value, u) || o.value !== d;
      if (!(!o.value || !i.value || !h))
        if (s.value)
          s.value.setOptions(t.value), a.value && ((m = l.value) == null || m.removeMarker(s.value), (p = l.value) == null || p.addMarker(s.value));
        else {
          if (Le(n))
            s.value = S(
              new i.value[n](t.value)
            );
          else if (xe(n)) {
            const g = t.value;
            g.element && (s.value = S(new i.value[n](g)));
          } else
            s.value = S(
              new i.value[n]({
                ...t.value,
                map: o.value
              })
            );
          s.value && (a.value ? (f = l.value) == null || f.addMarker(s.value) : (Le(n) || xe(n)) && s.value.setMap(o.value)), e.forEach((g) => {
            var v;
            (v = s.value) == null || v.addListener(g, (E) => r(g, E));
          });
        }
    },
    {
      immediate: !0,
      flush: "post"
    }
  ), B(() => {
    var c, d;
    s.value && ((c = i.value) == null || c.event.clearInstanceListeners(s.value), a.value ? (d = l.value) == null || d.removeMarker(s.value) : s.value.setMap(null));
  }), s;
}, Ie = [
  "animation_changed",
  "click",
  "dblclick",
  "rightclick",
  "dragstart",
  "dragend",
  "drag",
  "mouseover",
  "mousedown",
  "mouseout",
  "mouseup",
  "draggable_changed",
  "clickable_changed",
  "contextmenu",
  "cursor_changed",
  "flat_changed",
  "zindex_changed",
  "icon_changed",
  "position_changed",
  "shape_changed",
  "title_changed",
  "visible_changed"
], Rr = P({
  name: "Marker",
  props: {
    options: {
      type: Object,
      required: !0
    }
  },
  emits: Ie,
  setup(n, { emit: e, expose: t, slots: r }) {
    const s = j(n, "options"), o = J("Marker", Ie, s, e);
    return G(_e, o), t({ marker: o }), () => {
      var i;
      return (i = r.default) == null ? void 0 : i.call(r);
    };
  }
}), $r = P({
  name: "Polyline",
  props: {
    options: {
      type: Object,
      required: !0
    }
  },
  emits: H,
  setup(n, { emit: e }) {
    const t = j(n, "options");
    return { polyline: J("Polyline", H, t, e) };
  },
  render: () => null
}), Nr = P({
  name: "Polygon",
  props: {
    options: {
      type: Object,
      required: !0
    }
  },
  emits: H,
  setup(n, { emit: e }) {
    const t = j(n, "options");
    return { polygon: J("Polygon", H, t, e) };
  },
  render: () => null
}), je = H.concat(["bounds_changed"]), Br = P({
  name: "Rectangle",
  props: {
    options: {
      type: Object,
      required: !0
    }
  },
  emits: je,
  setup(n, { emit: e }) {
    const t = j(n, "options");
    return { rectangle: J("Rectangle", je, t, e) };
  },
  render: () => null
}), Re = H.concat(["center_changed", "radius_changed"]), Dr = P({
  name: "Circle",
  props: {
    options: {
      type: Object,
      required: !0
    }
  },
  emits: Re,
  setup(n, { emit: e }) {
    const t = j(n, "options");
    return { circle: J("Circle", Re, t, e) };
  },
  render: () => null
}), Mt = P({
  props: {
    position: {
      type: String,
      required: !0
    },
    index: {
      type: Number,
      default: 1
    }
  },
  emits: ["content:loaded"],
  setup(n, { emit: e }) {
    const t = w(null), r = k(D, w()), s = k(Z, w()), o = k(Xe, w(!1)), i = q(
      [o, s, t],
      ([c, d, u]) => {
        d && c && u && (l(n.position), e("content:loaded"), setTimeout(i, 0));
      },
      { immediate: !0 }
    ), l = (c) => {
      if (r.value && s.value && t.value) {
        const d = s.value.ControlPosition[c];
        t.value.index = n.index, r.value.controls[d].push(t.value);
      }
    }, a = (c) => {
      if (r.value && s.value) {
        let d = null;
        const u = s.value.ControlPosition[c];
        r.value.controls[u].forEach((h, m) => {
          h === t.value && (d = m);
        }), d !== null && r.value.controls[u].removeAt(d);
      }
    };
    return B(() => a(n.position)), q(
      () => n.position,
      (c, d) => {
        a(d), l(c);
      }
    ), q(
      () => n.index,
      (c) => {
        t.value && (t.value.index = c);
      }
    ), { controlRef: t };
  }
});
const bt = {
  ref: "controlRef",
  class: "custom-control-wrapper"
};
function Pt(n, e, t, r, s, o) {
  return V(), z("div", bt, [
    W(n.$slots, "default", {}, void 0, !0)
  ], 512);
}
const Zr = /* @__PURE__ */ re(Mt, [["render", Pt], ["__scopeId", "data-v-ab9120cd"]]), $e = [
  "closeclick",
  "content_changed",
  "domready",
  "position_changed",
  "visible",
  "zindex_changed"
], qt = P({
  inheritAttrs: !1,
  props: {
    options: {
      type: Object,
      default: () => ({})
    },
    modelValue: {
      type: Boolean
    }
  },
  emits: [...$e, "update:modelValue"],
  setup(n, { slots: e, emit: t, expose: r }) {
    const s = w(), o = w(), i = k(D, w()), l = k(Z, w()), a = k(_e, w());
    let c, d = n.modelValue;
    const u = K(() => {
      var f;
      return (f = e.default) == null ? void 0 : f.call(e).some((g) => g.type !== ye);
    }), h = (f) => {
      d = f, t("update:modelValue", f);
    }, m = (f) => {
      s.value && (s.value.open({ map: i.value, anchor: a.value, ...f }), h(!0));
    }, p = () => {
      s.value && (s.value.close(), h(!1));
    };
    return Ye(() => {
      q(
        [i, () => n.options],
        ([f, g], [v, E]) => {
          var M;
          const y = !ee(g, E) || i.value !== v;
          i.value && l.value && y && (s.value ? (s.value.setOptions({
            ...g,
            content: u.value ? o.value : g.content
          }), a.value || m()) : (s.value = S(
            new l.value.InfoWindow({
              ...g,
              content: u.value ? o.value : g.content
            })
          ), a.value && (c = a.value.addListener("click", () => {
            m();
          })), (!a.value || d) && m(), $e.forEach((O) => {
            var b;
            (b = s.value) == null || b.addListener(O, (C) => t(O, C));
          }), (M = s.value) == null || M.addListener("closeclick", () => h(!1))));
        },
        {
          immediate: !0
        }
      ), q(
        () => n.modelValue,
        (f) => {
          f !== d && (f ? m() : p());
        }
      );
    }), B(() => {
      var f;
      c && c.remove(), s.value && ((f = l.value) == null || f.event.clearInstanceListeners(s.value), p());
    }), r({ infoWindow: s, open: m, close: p }), { infoWindow: s, infoWindowRef: o, hasSlotContent: u, open: m, close: p };
  }
});
const St = {
  key: 0,
  class: "info-window-wrapper"
};
function At(n, e, t, r, s, o) {
  return n.hasSlotContent ? (V(), z("div", St, [
    le("div", we({ ref: "infoWindowRef" }, n.$attrs), [
      W(n.$slots, "default", {}, void 0, !0)
    ], 16)
  ])) : Ee("", !0);
}
const Fr = /* @__PURE__ */ re(qt, [["render", At], ["__scopeId", "data-v-f0c09f6e"]]);
var Tt = Object.getOwnPropertyNames, Lt = Object.getOwnPropertySymbols, xt = Object.prototype.hasOwnProperty;
function Ne(n, e) {
  return function(r, s, o) {
    return n(r, s, o) && e(r, s, o);
  };
}
function se(n) {
  return function(t, r, s) {
    if (!t || !r || typeof t != "object" || typeof r != "object")
      return n(t, r, s);
    var o = s.cache, i = o.get(t), l = o.get(r);
    if (i && l)
      return i === r && l === t;
    o.set(t, r), o.set(r, t);
    var a = n(t, r, s);
    return o.delete(t), o.delete(r), a;
  };
}
function Be(n) {
  return Tt(n).concat(Lt(n));
}
var It = Object.hasOwn || function(n, e) {
  return xt.call(n, e);
};
function F(n, e) {
  return n === e || !n && !e && n !== n && e !== e;
}
var jt = "__v", Rt = "__o", $t = "_owner", De = Object.getOwnPropertyDescriptor, Ze = Object.keys;
function Nt(n, e, t) {
  var r = n.length;
  if (e.length !== r)
    return !1;
  for (; r-- > 0; )
    if (!t.equals(n[r], e[r], r, r, n, e, t))
      return !1;
  return !0;
}
function Bt(n, e) {
  return F(n.getTime(), e.getTime());
}
function Dt(n, e) {
  return n.name === e.name && n.message === e.message && n.cause === e.cause && n.stack === e.stack;
}
function Zt(n, e) {
  return n === e;
}
function Fe(n, e, t) {
  var r = n.size;
  if (r !== e.size)
    return !1;
  if (!r)
    return !0;
  for (var s = new Array(r), o = n.entries(), i, l, a = 0; (i = o.next()) && !i.done; ) {
    for (var c = e.entries(), d = !1, u = 0; (l = c.next()) && !l.done; ) {
      if (s[u]) {
        u++;
        continue;
      }
      var h = i.value, m = l.value;
      if (t.equals(h[0], m[0], a, u, n, e, t) && t.equals(h[1], m[1], h[0], m[0], n, e, t)) {
        d = s[u] = !0;
        break;
      }
      u++;
    }
    if (!d)
      return !1;
    a++;
  }
  return !0;
}
var Ft = F;
function Ut(n, e, t) {
  var r = Ze(n), s = r.length;
  if (Ze(e).length !== s)
    return !1;
  for (; s-- > 0; )
    if (!Qe(n, e, t, r[s]))
      return !1;
  return !0;
}
function Y(n, e, t) {
  var r = Be(n), s = r.length;
  if (Be(e).length !== s)
    return !1;
  for (var o, i, l; s-- > 0; )
    if (o = r[s], !Qe(n, e, t, o) || (i = De(n, o), l = De(e, o), (i || l) && (!i || !l || i.configurable !== l.configurable || i.enumerable !== l.enumerable || i.writable !== l.writable)))
      return !1;
  return !0;
}
function Gt(n, e) {
  return F(n.valueOf(), e.valueOf());
}
function Vt(n, e) {
  return n.source === e.source && n.flags === e.flags;
}
function Ue(n, e, t) {
  var r = n.size;
  if (r !== e.size)
    return !1;
  if (!r)
    return !0;
  for (var s = new Array(r), o = n.values(), i, l; (i = o.next()) && !i.done; ) {
    for (var a = e.values(), c = !1, d = 0; (l = a.next()) && !l.done; ) {
      if (!s[d] && t.equals(i.value, l.value, i.value, l.value, n, e, t)) {
        c = s[d] = !0;
        break;
      }
      d++;
    }
    if (!c)
      return !1;
  }
  return !0;
}
function zt(n, e) {
  var t = n.length;
  if (e.length !== t)
    return !1;
  for (; t-- > 0; )
    if (n[t] !== e[t])
      return !1;
  return !0;
}
function Wt(n, e) {
  return n.hostname === e.hostname && n.pathname === e.pathname && n.protocol === e.protocol && n.port === e.port && n.hash === e.hash && n.username === e.username && n.password === e.password;
}
function Qe(n, e, t, r) {
  return (r === $t || r === Rt || r === jt) && (n.$$typeof || e.$$typeof) ? !0 : It(e, r) && t.equals(n[r], e[r], r, r, n, e, t);
}
var Kt = "[object Arguments]", Ht = "[object Boolean]", Jt = "[object Date]", Yt = "[object Error]", Xt = "[object Map]", Qt = "[object Number]", er = "[object Object]", tr = "[object RegExp]", rr = "[object Set]", nr = "[object String]", sr = "[object URL]", or = Array.isArray, Ge = typeof ArrayBuffer == "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null, Ve = Object.assign, ir = Object.prototype.toString.call.bind(Object.prototype.toString);
function ar(n) {
  var e = n.areArraysEqual, t = n.areDatesEqual, r = n.areErrorsEqual, s = n.areFunctionsEqual, o = n.areMapsEqual, i = n.areNumbersEqual, l = n.areObjectsEqual, a = n.arePrimitiveWrappersEqual, c = n.areRegExpsEqual, d = n.areSetsEqual, u = n.areTypedArraysEqual, h = n.areUrlsEqual;
  return function(p, f, g) {
    if (p === f)
      return !0;
    if (p == null || f == null)
      return !1;
    var v = typeof p;
    if (v !== typeof f)
      return !1;
    if (v !== "object")
      return v === "number" ? i(p, f, g) : v === "function" ? s(p, f, g) : !1;
    var E = p.constructor;
    if (E !== f.constructor)
      return !1;
    if (E === Object)
      return l(p, f, g);
    if (or(p))
      return e(p, f, g);
    if (Ge != null && Ge(p))
      return u(p, f, g);
    if (E === Date)
      return t(p, f, g);
    if (E === RegExp)
      return c(p, f, g);
    if (E === Map)
      return o(p, f, g);
    if (E === Set)
      return d(p, f, g);
    var y = ir(p);
    return y === Jt ? t(p, f, g) : y === tr ? c(p, f, g) : y === Xt ? o(p, f, g) : y === rr ? d(p, f, g) : y === er ? typeof p.then != "function" && typeof f.then != "function" && l(p, f, g) : y === sr ? h(p, f, g) : y === Yt ? r(p, f, g) : y === Kt ? l(p, f, g) : y === Ht || y === Qt || y === nr ? a(p, f, g) : !1;
  };
}
function lr(n) {
  var e = n.circular, t = n.createCustomConfig, r = n.strict, s = {
    areArraysEqual: r ? Y : Nt,
    areDatesEqual: Bt,
    areErrorsEqual: Dt,
    areFunctionsEqual: Zt,
    areMapsEqual: r ? Ne(Fe, Y) : Fe,
    areNumbersEqual: Ft,
    areObjectsEqual: r ? Y : Ut,
    arePrimitiveWrappersEqual: Gt,
    areRegExpsEqual: Vt,
    areSetsEqual: r ? Ne(Ue, Y) : Ue,
    areTypedArraysEqual: r ? Y : zt,
    areUrlsEqual: Wt
  };
  if (t && (s = Ve({}, s, t(s))), e) {
    var o = se(s.areArraysEqual), i = se(s.areMapsEqual), l = se(s.areObjectsEqual), a = se(s.areSetsEqual);
    s = Ve({}, s, {
      areArraysEqual: o,
      areMapsEqual: i,
      areObjectsEqual: l,
      areSetsEqual: a
    });
  }
  return s;
}
function ur(n) {
  return function(e, t, r, s, o, i, l) {
    return n(e, t, l);
  };
}
function cr(n) {
  var e = n.circular, t = n.comparator, r = n.createState, s = n.equals, o = n.strict;
  if (r)
    return function(a, c) {
      var d = r(), u = d.cache, h = u === void 0 ? e ? /* @__PURE__ */ new WeakMap() : void 0 : u, m = d.meta;
      return t(a, c, {
        cache: h,
        equals: s,
        meta: m,
        strict: o
      });
    };
  if (e)
    return function(a, c) {
      return t(a, c, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals: s,
        meta: void 0,
        strict: o
      });
    };
  var i = {
    cache: void 0,
    equals: s,
    meta: void 0,
    strict: o
  };
  return function(a, c) {
    return t(a, c, i);
  };
}
var ae = R();
R({ strict: !0 });
R({ circular: !0 });
R({
  circular: !0,
  strict: !0
});
R({
  createInternalComparator: function() {
    return F;
  }
});
R({
  strict: !0,
  createInternalComparator: function() {
    return F;
  }
});
R({
  circular: !0,
  createInternalComparator: function() {
    return F;
  }
});
R({
  circular: !0,
  createInternalComparator: function() {
    return F;
  },
  strict: !0
});
function R(n) {
  n === void 0 && (n = {});
  var e = n.circular, t = e === void 0 ? !1 : e, r = n.createInternalComparator, s = n.createState, o = n.strict, i = o === void 0 ? !1 : o, l = lr(n), a = ar(l), c = r ? r(a) : ur(a);
  return cr({ circular: t, comparator: a, createState: s, equals: c, strict: i });
}
const ze = [
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
], he = 1, X = 8;
class Ce {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(e) {
    if (!(e instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    const [t, r] = new Uint8Array(e, 0, 2);
    if (t !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    const s = r >> 4;
    if (s !== he)
      throw new Error(`Got v${s} data when expected v${he}.`);
    const o = ze[r & 15];
    if (!o)
      throw new Error("Unrecognized array type.");
    const [i] = new Uint16Array(e, 2, 1), [l] = new Uint32Array(e, 4, 1);
    return new Ce(l, i, o, e);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(e, t = 64, r = Float64Array, s) {
    if (isNaN(e) || e < 0)
      throw new Error(`Unpexpected numItems value: ${e}.`);
    this.numItems = +e, this.nodeSize = Math.min(Math.max(+t, 2), 65535), this.ArrayType = r, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
    const o = ze.indexOf(this.ArrayType), i = e * 2 * this.ArrayType.BYTES_PER_ELEMENT, l = e * this.IndexArrayType.BYTES_PER_ELEMENT, a = (8 - l % 8) % 8;
    if (o < 0)
      throw new Error(`Unexpected typed array class: ${r}.`);
    s && s instanceof ArrayBuffer ? (this.data = s, this.ids = new this.IndexArrayType(this.data, X, e), this.coords = new this.ArrayType(this.data, X + l + a, e * 2), this._pos = e * 2, this._finished = !0) : (this.data = new ArrayBuffer(X + i + l + a), this.ids = new this.IndexArrayType(this.data, X, e), this.coords = new this.ArrayType(this.data, X + l + a, e * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (he << 4) + o]), new Uint16Array(this.data, 2, 1)[0] = t, new Uint32Array(this.data, 4, 1)[0] = e);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(e, t) {
    const r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = e, this.coords[this._pos++] = t, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    const e = this._pos >> 1;
    if (e !== this.numItems)
      throw new Error(`Added ${e} items when expected ${this.numItems}.`);
    return ve(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(e, t, r, s) {
    if (!this._finished)
      throw new Error("Data not yet indexed - call index.finish().");
    const { ids: o, coords: i, nodeSize: l } = this, a = [0, o.length - 1, 0], c = [];
    for (; a.length; ) {
      const d = a.pop() || 0, u = a.pop() || 0, h = a.pop() || 0;
      if (u - h <= l) {
        for (let g = h; g <= u; g++) {
          const v = i[2 * g], E = i[2 * g + 1];
          v >= e && v <= r && E >= t && E <= s && c.push(o[g]);
        }
        continue;
      }
      const m = h + u >> 1, p = i[2 * m], f = i[2 * m + 1];
      p >= e && p <= r && f >= t && f <= s && c.push(o[m]), (d === 0 ? e <= p : t <= f) && (a.push(h), a.push(m - 1), a.push(1 - d)), (d === 0 ? r >= p : s >= f) && (a.push(m + 1), a.push(u), a.push(1 - d));
    }
    return c;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(e, t, r) {
    if (!this._finished)
      throw new Error("Data not yet indexed - call index.finish().");
    const { ids: s, coords: o, nodeSize: i } = this, l = [0, s.length - 1, 0], a = [], c = r * r;
    for (; l.length; ) {
      const d = l.pop() || 0, u = l.pop() || 0, h = l.pop() || 0;
      if (u - h <= i) {
        for (let g = h; g <= u; g++)
          We(o[2 * g], o[2 * g + 1], e, t) <= c && a.push(s[g]);
        continue;
      }
      const m = h + u >> 1, p = o[2 * m], f = o[2 * m + 1];
      We(p, f, e, t) <= c && a.push(s[m]), (d === 0 ? e - r <= p : t - r <= f) && (l.push(h), l.push(m - 1), l.push(1 - d)), (d === 0 ? e + r >= p : t + r >= f) && (l.push(m + 1), l.push(u), l.push(1 - d));
    }
    return a;
  }
}
function ve(n, e, t, r, s, o) {
  if (s - r <= t)
    return;
  const i = r + s >> 1;
  et(n, e, i, r, s, o), ve(n, e, t, r, i - 1, 1 - o), ve(n, e, t, i + 1, s, 1 - o);
}
function et(n, e, t, r, s, o) {
  for (; s > r; ) {
    if (s - r > 600) {
      const c = s - r + 1, d = t - r + 1, u = Math.log(c), h = 0.5 * Math.exp(2 * u / 3), m = 0.5 * Math.sqrt(u * h * (c - h) / c) * (d - c / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(t - d * h / c + m)), f = Math.min(s, Math.floor(t + (c - d) * h / c + m));
      et(n, e, t, p, f, o);
    }
    const i = e[2 * t + o];
    let l = r, a = s;
    for (Q(n, e, r, t), e[2 * s + o] > i && Q(n, e, r, s); l < a; ) {
      for (Q(n, e, l, a), l++, a--; e[2 * l + o] < i; )
        l++;
      for (; e[2 * a + o] > i; )
        a--;
    }
    e[2 * r + o] === i ? Q(n, e, r, a) : (a++, Q(n, e, a, s)), a <= t && (r = a + 1), t <= a && (s = a - 1);
  }
}
function Q(n, e, t, r) {
  me(n, t, r), me(e, 2 * t, 2 * r), me(e, 2 * t + 1, 2 * r + 1);
}
function me(n, e, t) {
  const r = n[e];
  n[e] = n[t], n[t] = r;
}
function We(n, e, t, r) {
  const s = n - t, o = e - r;
  return s * s + o * o;
}
const dr = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (n) => n
  // props => ({sum: props.my_value})
}, Ke = Math.fround || ((n) => (e) => (n[0] = +e, n[0]))(new Float32Array(1)), $ = 2, x = 3, ge = 4, L = 5, tt = 6;
class rt {
  constructor(e) {
    this.options = Object.assign(Object.create(dr), e), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(e) {
    const { log: t, minZoom: r, maxZoom: s } = this.options;
    t && console.time("total time");
    const o = `prepare ${e.length} points`;
    t && console.time(o), this.points = e;
    const i = [];
    for (let a = 0; a < e.length; a++) {
      const c = e[a];
      if (!c.geometry)
        continue;
      const [d, u] = c.geometry.coordinates, h = Ke(oe(d)), m = Ke(ie(u));
      i.push(
        h,
        m,
        // projected point coordinates
        1 / 0,
        // the last zoom the point was processed at
        a,
        // index of the source feature in the original input array
        -1,
        // parent cluster id
        1
        // number of points in a cluster
      ), this.options.reduce && i.push(0);
    }
    let l = this.trees[s + 1] = this._createTree(i);
    t && console.timeEnd(o);
    for (let a = s; a >= r; a--) {
      const c = +Date.now();
      l = this.trees[a] = this._createTree(this._cluster(l, a)), t && console.log("z%d: %d clusters in %dms", a, l.numItems, +Date.now() - c);
    }
    return t && console.timeEnd("total time"), this;
  }
  getClusters(e, t) {
    let r = ((e[0] + 180) % 360 + 360) % 360 - 180;
    const s = Math.max(-90, Math.min(90, e[1]));
    let o = e[2] === 180 ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180;
    const i = Math.max(-90, Math.min(90, e[3]));
    if (e[2] - e[0] >= 360)
      r = -180, o = 180;
    else if (r > o) {
      const u = this.getClusters([r, s, 180, i], t), h = this.getClusters([-180, s, o, i], t);
      return u.concat(h);
    }
    const l = this.trees[this._limitZoom(t)], a = l.range(oe(r), ie(i), oe(o), ie(s)), c = l.data, d = [];
    for (const u of a) {
      const h = this.stride * u;
      d.push(c[h + L] > 1 ? He(c, h, this.clusterProps) : this.points[c[h + x]]);
    }
    return d;
  }
  getChildren(e) {
    const t = this._getOriginId(e), r = this._getOriginZoom(e), s = "No cluster with the specified id.", o = this.trees[r];
    if (!o)
      throw new Error(s);
    const i = o.data;
    if (t * this.stride >= i.length)
      throw new Error(s);
    const l = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), a = i[t * this.stride], c = i[t * this.stride + 1], d = o.within(a, c, l), u = [];
    for (const h of d) {
      const m = h * this.stride;
      i[m + ge] === e && u.push(i[m + L] > 1 ? He(i, m, this.clusterProps) : this.points[i[m + x]]);
    }
    if (u.length === 0)
      throw new Error(s);
    return u;
  }
  getLeaves(e, t, r) {
    t = t || 10, r = r || 0;
    const s = [];
    return this._appendLeaves(s, e, t, r, 0), s;
  }
  getTile(e, t, r) {
    const s = this.trees[this._limitZoom(e)], o = Math.pow(2, e), { extent: i, radius: l } = this.options, a = l / i, c = (r - a) / o, d = (r + 1 + a) / o, u = {
      features: []
    };
    return this._addTileFeatures(
      s.range((t - a) / o, c, (t + 1 + a) / o, d),
      s.data,
      t,
      r,
      o,
      u
    ), t === 0 && this._addTileFeatures(
      s.range(1 - a / o, c, 1, d),
      s.data,
      o,
      r,
      o,
      u
    ), t === o - 1 && this._addTileFeatures(
      s.range(0, c, a / o, d),
      s.data,
      -1,
      r,
      o,
      u
    ), u.features.length ? u : null;
  }
  getClusterExpansionZoom(e) {
    let t = this._getOriginZoom(e) - 1;
    for (; t <= this.options.maxZoom; ) {
      const r = this.getChildren(e);
      if (t++, r.length !== 1)
        break;
      e = r[0].properties.cluster_id;
    }
    return t;
  }
  _appendLeaves(e, t, r, s, o) {
    const i = this.getChildren(t);
    for (const l of i) {
      const a = l.properties;
      if (a && a.cluster ? o + a.point_count <= s ? o += a.point_count : o = this._appendLeaves(e, a.cluster_id, r, s, o) : o < s ? o++ : e.push(l), e.length === r)
        break;
    }
    return o;
  }
  _createTree(e) {
    const t = new Ce(e.length / this.stride | 0, this.options.nodeSize, Float32Array);
    for (let r = 0; r < e.length; r += this.stride)
      t.add(e[r], e[r + 1]);
    return t.finish(), t.data = e, t;
  }
  _addTileFeatures(e, t, r, s, o, i) {
    for (const l of e) {
      const a = l * this.stride, c = t[a + L] > 1;
      let d, u, h;
      if (c)
        d = nt(t, a, this.clusterProps), u = t[a], h = t[a + 1];
      else {
        const f = this.points[t[a + x]];
        d = f.properties;
        const [g, v] = f.geometry.coordinates;
        u = oe(g), h = ie(v);
      }
      const m = {
        type: 1,
        geometry: [[
          Math.round(this.options.extent * (u * o - r)),
          Math.round(this.options.extent * (h * o - s))
        ]],
        tags: d
      };
      let p;
      c || this.options.generateId ? p = t[a + x] : p = this.points[t[a + x]].id, p !== void 0 && (m.id = p), i.features.push(m);
    }
  }
  _limitZoom(e) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+e), this.options.maxZoom + 1));
  }
  _cluster(e, t) {
    const { radius: r, extent: s, reduce: o, minPoints: i } = this.options, l = r / (s * Math.pow(2, t)), a = e.data, c = [], d = this.stride;
    for (let u = 0; u < a.length; u += d) {
      if (a[u + $] <= t)
        continue;
      a[u + $] = t;
      const h = a[u], m = a[u + 1], p = e.within(a[u], a[u + 1], l), f = a[u + L];
      let g = f;
      for (const v of p) {
        const E = v * d;
        a[E + $] > t && (g += a[E + L]);
      }
      if (g > f && g >= i) {
        let v = h * f, E = m * f, y, M = -1;
        const O = ((u / d | 0) << 5) + (t + 1) + this.points.length;
        for (const b of p) {
          const C = b * d;
          if (a[C + $] <= t)
            continue;
          a[C + $] = t;
          const T = a[C + L];
          v += a[C] * T, E += a[C + 1] * T, a[C + ge] = O, o && (y || (y = this._map(a, u, !0), M = this.clusterProps.length, this.clusterProps.push(y)), o(y, this._map(a, C)));
        }
        a[u + ge] = O, c.push(v / g, E / g, 1 / 0, O, -1, g), o && c.push(M);
      } else {
        for (let v = 0; v < d; v++)
          c.push(a[u + v]);
        if (g > 1)
          for (const v of p) {
            const E = v * d;
            if (!(a[E + $] <= t)) {
              a[E + $] = t;
              for (let y = 0; y < d; y++)
                c.push(a[E + y]);
            }
          }
      }
    }
    return c;
  }
  // get index of the point from which the cluster originated
  _getOriginId(e) {
    return e - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(e) {
    return (e - this.points.length) % 32;
  }
  _map(e, t, r) {
    if (e[t + L] > 1) {
      const i = this.clusterProps[e[t + tt]];
      return r ? Object.assign({}, i) : i;
    }
    const s = this.points[e[t + x]].properties, o = this.options.map(s);
    return r && o === s ? Object.assign({}, o) : o;
  }
}
function He(n, e, t) {
  return {
    type: "Feature",
    id: n[e + x],
    properties: nt(n, e, t),
    geometry: {
      type: "Point",
      coordinates: [pr(n[e]), fr(n[e + 1])]
    }
  };
}
function nt(n, e, t) {
  const r = n[e + L], s = r >= 1e4 ? `${Math.round(r / 1e3)}k` : r >= 1e3 ? `${Math.round(r / 100) / 10}k` : r, o = n[e + tt], i = o === -1 ? {} : Object.assign({}, t[o]);
  return Object.assign(i, {
    cluster: !0,
    cluster_id: n[e + x],
    point_count: r,
    point_count_abbreviated: s
  });
}
function oe(n) {
  return n / 360 + 0.5;
}
function ie(n) {
  const e = Math.sin(n * Math.PI / 180), t = 0.5 - 0.25 * Math.log((1 + e) / (1 - e)) / Math.PI;
  return t < 0 ? 0 : t > 1 ? 1 : t;
}
function pr(n) {
  return (n - 0.5) * 360;
}
function fr(n) {
  const e = (180 - n * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(e)) / Math.PI - 90;
}
function Oe(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var s = 0, r = Object.getOwnPropertySymbols(n); s < r.length; s++)
      e.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[s]) && (t[r[s]] = n[r[s]]);
  return t;
}
class _ {
  static isAdvancedMarkerAvailable(e) {
    return google.maps.marker && e.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(e) {
    return google.maps.marker && e instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(e, t) {
    this.isAdvancedMarker(e) ? e.map = t : e.setMap(t);
  }
  static getPosition(e) {
    if (this.isAdvancedMarker(e)) {
      if (e.position) {
        if (e.position instanceof google.maps.LatLng)
          return e.position;
        if (Number.isFinite(e.position.lat) && Number.isFinite(e.position.lng))
          return new google.maps.LatLng(e.position.lat, e.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return e.getPosition();
  }
  static getVisible(e) {
    return this.isAdvancedMarker(e) ? !0 : e.getVisible();
  }
}
class te {
  constructor({ markers: e, position: t }) {
    this.markers = [], e && (this.markers = e), t && (t instanceof google.maps.LatLng ? this._position = t : this._position = new google.maps.LatLng(t));
  }
  get bounds() {
    if (this.markers.length === 0 && !this._position)
      return;
    const e = new google.maps.LatLngBounds(this._position, this._position);
    for (const t of this.markers)
      e.extend(_.getPosition(t));
    return e;
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((e) => _.getVisible(e)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(e) {
    this.markers.push(e);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (_.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
function A(n, e = "assertion failed") {
  if (n == null)
    throw Error(e);
}
const hr = (n, e, t, r) => {
  const s = n.getBounds();
  A(s);
  const o = st(s, e, r);
  return t.filter((i) => o.contains(_.getPosition(i)));
}, st = (n, e, t) => {
  const { northEast: r, southWest: s } = gr(n, e), o = vr({ northEast: r, southWest: s }, t);
  return yr(o, e);
}, mr = (n, e, t) => {
  const r = st(n, e, t), s = r.getNorthEast(), o = r.getSouthWest();
  return [o.lng(), o.lat(), s.lng(), s.lat()];
}, gr = (n, e) => {
  const t = e.fromLatLngToDivPixel(n.getNorthEast()), r = e.fromLatLngToDivPixel(n.getSouthWest());
  return A(t), A(r), { northEast: t, southWest: r };
}, vr = ({ northEast: n, southWest: e }, t) => (n.x += t, n.y -= t, e.x -= t, e.y += t, { northEast: n, southWest: e }), yr = ({ northEast: n, southWest: e }, t) => {
  const r = t.fromDivPixelToLatLng(e), s = t.fromDivPixelToLatLng(n);
  return new google.maps.LatLngBounds(r, s);
};
class ot {
  constructor({ maxZoom: e = 16 }) {
    this.maxZoom = e;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop({ markers: e }) {
    return Er(e);
  }
}
class wr extends ot {
  constructor(e) {
    var { viewportPadding: t = 60 } = e, r = Oe(e, ["viewportPadding"]);
    super(r), this.viewportPadding = 60, this.viewportPadding = t;
  }
  calculate({ markers: e, map: t, mapCanvasProjection: r }) {
    const s = t.getZoom();
    return A(s), s >= this.maxZoom ? {
      clusters: this.noop({
        markers: e
      }),
      changed: !1
    } : {
      clusters: this.cluster({
        markers: hr(t, r, e, this.viewportPadding),
        map: t,
        mapCanvasProjection: r
      })
    };
  }
}
const Er = (n) => n.map((t) => new te({
  position: _.getPosition(t),
  markers: [t]
}));
class _r extends ot {
  constructor(e) {
    var { maxZoom: t, radius: r = 60 } = e, s = Oe(e, ["maxZoom", "radius"]);
    super({ maxZoom: t }), this.markers = [], this.clusters = [], this.state = { zoom: -1 }, this.superCluster = new rt(Object.assign({ maxZoom: this.maxZoom, radius: r }, s));
  }
  calculate(e) {
    let t = !1, r = e.map.getZoom();
    A(r), r = Math.round(r);
    const s = { zoom: r };
    if (!ae(e.markers, this.markers)) {
      t = !0, this.markers = [...e.markers];
      const o = this.markers.map((i) => {
        const l = _.getPosition(i);
        return {
          type: "Feature",
          geometry: { type: "Point", coordinates: [l.lng(), l.lat()] },
          properties: { marker: i }
        };
      });
      this.superCluster.load(o);
    }
    return t || (this.state.zoom <= this.maxZoom || s.zoom <= this.maxZoom) && (t = !ae(this.state, s)), this.state = s, e.markers.length === 0 ? (this.clusters = [], { clusters: this.clusters, changed: t }) : (t && (this.clusters = this.cluster(e)), { clusters: this.clusters, changed: t });
  }
  cluster({ map: e }) {
    const t = e.getZoom();
    return A(t), this.superCluster.getClusters([-180, -90, 180, 90], Math.round(t)).map((r) => this.transformCluster(r));
  }
  transformCluster({ geometry: { coordinates: [e, t] }, properties: r }) {
    if (r.cluster)
      return new te({
        markers: this.superCluster.getLeaves(r.cluster_id, 1 / 0).map((o) => o.properties.marker),
        position: { lat: t, lng: e }
      });
    const s = r.marker;
    return new te({
      markers: [s],
      position: _.getPosition(s)
    });
  }
}
class kr extends wr {
  constructor(e) {
    var { maxZoom: t, radius: r = 60, viewportPadding: s = 60 } = e, o = Oe(e, ["maxZoom", "radius", "viewportPadding"]);
    super({ maxZoom: t, viewportPadding: s }), this.markers = [], this.clusters = [], this.superCluster = new rt(Object.assign({ maxZoom: this.maxZoom, radius: r }, o)), this.state = { zoom: -1, view: [0, 0, 0, 0] };
  }
  calculate(e) {
    const t = this.getViewportState(e);
    let r = !ae(this.state, t);
    if (!ae(e.markers, this.markers)) {
      r = !0, this.markers = [...e.markers];
      const s = this.markers.map((o) => {
        const i = _.getPosition(o);
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: [i.lng(), i.lat()]
          },
          properties: { marker: o }
        };
      });
      this.superCluster.load(s);
    }
    return r && (this.clusters = this.cluster(e), this.state = t), { clusters: this.clusters, changed: r };
  }
  cluster(e) {
    const t = this.getViewportState(e);
    return this.superCluster.getClusters(t.view, t.zoom).map((r) => this.transformCluster(r));
  }
  transformCluster({ geometry: { coordinates: [e, t] }, properties: r }) {
    if (r.cluster)
      return new te({
        markers: this.superCluster.getLeaves(r.cluster_id, 1 / 0).map((o) => o.properties.marker),
        position: { lat: t, lng: e }
      });
    const s = r.marker;
    return new te({
      markers: [s],
      position: _.getPosition(s)
    });
  }
  getViewportState(e) {
    const t = e.map.getZoom(), r = e.map.getBounds();
    return A(t), A(r), {
      zoom: Math.round(t),
      view: mr(r, e.mapCanvasProjection, this.viewportPadding)
    };
  }
}
class Cr {
  constructor(e, t) {
    this.markers = { sum: e.length };
    const r = t.map((o) => o.count), s = r.reduce((o, i) => o + i, 0);
    this.clusters = {
      count: t.length,
      markers: {
        mean: s / t.length,
        sum: s,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class Or {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render({ count: e, position: t }, r, s) {
    const i = `<svg fill="${e > Math.max(10, r.clusters.markers.mean) ? "#ff0000" : "#0000ff"}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">${e}</text>
</svg>`, l = `Cluster of ${e} markers`, a = Number(google.maps.Marker.MAX_ZINDEX) + e;
    if (_.isAdvancedMarkerAvailable(s)) {
      const u = new DOMParser().parseFromString(i, "image/svg+xml").documentElement;
      u.setAttribute("transform", "translate(0 25)");
      const h = {
        map: s,
        position: t,
        zIndex: a,
        title: l,
        content: u
      };
      return new google.maps.marker.AdvancedMarkerElement(h);
    }
    const c = {
      position: t,
      zIndex: a,
      title: l,
      icon: {
        url: `data:image/svg+xml;base64,${btoa(i)}`,
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(c);
  }
}
function Mr(n, e) {
  for (let t in e.prototype)
    n.prototype[t] = e.prototype[t];
}
class Me {
  constructor() {
    Mr(Me, google.maps.OverlayView);
  }
}
var I;
(function(n) {
  n.CLUSTERING_BEGIN = "clusteringbegin", n.CLUSTERING_END = "clusteringend", n.CLUSTER_CLICK = "click", n.GMP_CLICK = "gmp-click";
})(I || (I = {}));
const br = (n, e, t) => {
  e.bounds && t.fitBounds(e.bounds);
};
class Pr extends Me {
  constructor({ map: e, markers: t = [], algorithmOptions: r = {}, algorithm: s = new _r(r), renderer: o = new Or(), onClusterClick: i = br }) {
    super(), this.map = null, this.idleListener = null, this.markers = [...t], this.clusters = [], this.algorithm = s, this.renderer = o, this.onClusterClick = i, e && this.setMap(e);
  }
  addMarker(e, t) {
    this.markers.includes(e) || (this.markers.push(e), t || this.render());
  }
  addMarkers(e, t) {
    e.forEach((r) => {
      this.addMarker(r, !0);
    }), t || this.render();
  }
  removeMarker(e, t) {
    const r = this.markers.indexOf(e);
    return r === -1 ? !1 : (_.setMap(e, null), this.markers.splice(r, 1), t || this.render(), !0);
  }
  removeMarkers(e, t) {
    let r = !1;
    return e.forEach((s) => {
      r = this.removeMarker(s, !0) || r;
    }), r && !t && this.render(), r;
  }
  clearMarkers(e) {
    this.markers.length = 0, e || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    const e = this.getMap();
    if (e instanceof google.maps.Map && e.getProjection()) {
      google.maps.event.trigger(this, I.CLUSTERING_BEGIN, this);
      const { clusters: t, changed: r } = this.algorithm.calculate({
        markers: this.markers,
        map: e,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        const s = /* @__PURE__ */ new Set();
        for (const i of t)
          i.markers.length == 1 && s.add(i.markers[0]);
        const o = [];
        for (const i of this.clusters)
          i.marker != null && (i.markers.length == 1 ? s.has(i.marker) || _.setMap(i.marker, null) : o.push(i.marker));
        this.clusters = t, this.renderClusters(), requestAnimationFrame(() => o.forEach((i) => _.setMap(i, null)));
      }
      google.maps.event.trigger(this, I.CLUSTERING_END, this);
    }
  }
  onAdd() {
    const e = this.getMap();
    A(e), this.idleListener = e.addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    this.idleListener && google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((e) => _.setMap(e, null)), this.clusters.forEach((e) => e.delete()), this.clusters = [];
  }
  renderClusters() {
    const e = new Cr(this.markers, this.clusters), t = this.getMap();
    this.clusters.forEach((r) => {
      if (r.markers.length === 1)
        r.marker = r.markers[0];
      else if (r.marker = this.renderer.render(r, e, t), r.markers.forEach((s) => _.setMap(s, null)), this.onClusterClick) {
        const s = _.isAdvancedMarker(r.marker) ? I.GMP_CLICK : I.CLUSTER_CLICK;
        r.marker.addListener(
          s,
          /* istanbul ignore next */
          (o) => {
            google.maps.event.trigger(this, I.CLUSTER_CLICK, r), this.onClusterClick(o, r, t);
          }
        );
      }
      _.setMap(r.marker, t);
    });
  }
}
const Je = Object.values(I), Ur = P({
  name: "MarkerCluster",
  props: {
    options: {
      type: Object,
      default: () => ({})
    }
  },
  emits: Je,
  setup(n, { emit: e, expose: t, slots: r }) {
    const s = w(), o = k(D, w()), i = k(Z, w());
    return G(ke, s), q(
      o,
      () => {
        o.value && (s.value = S(
          new Pr({
            map: o.value,
            // Better perf than the default `SuperClusterAlgorithm`. See:
            // https://github.com/googlemaps/js-markerclusterer/pull/640
            algorithm: new kr(n.options.algorithmOptions ?? {}),
            ...n.options
          })
        ), Je.forEach((l) => {
          var a;
          (a = s.value) == null || a.addListener(l, (c) => e(l, c));
        }));
      },
      {
        immediate: !0
      }
    ), B(() => {
      var l;
      s.value && ((l = i.value) == null || l.event.clearInstanceListeners(s.value), s.value.clearMarkers(), s.value.setMap(null));
    }), t({ markerCluster: s }), () => {
      var l;
      return (l = r.default) == null ? void 0 : l.call(r);
    };
  }
}), qr = P({
  inheritAttrs: !1,
  props: {
    options: {
      type: Object,
      required: !0
    }
  },
  setup(n, { slots: e, emit: t, expose: r }) {
    const s = w(), o = K(() => {
      var a;
      return (a = e.default) == null ? void 0 : a.call(e).some((c) => c.type !== ye);
    }), i = K(() => ({
      ...n.options,
      element: s.value
    })), l = J(ue, [], i, t);
    return r({
      customMarker: l
    }), { customMarkerRef: s, customMarker: l, hasSlotContent: o };
  }
});
const Sr = {
  key: 0,
  class: "custom-marker-wrapper"
};
function Ar(n, e, t, r, s, o) {
  return n.hasSlotContent ? (V(), z("div", Sr, [
    le("div", we({
      ref: "customMarkerRef",
      style: { cursor: n.$attrs.onClick ? "pointer" : void 0 }
    }, n.$attrs), [
      W(n.$slots, "default", {}, void 0, !0)
    ], 16)
  ])) : Ee("", !0);
}
const Gr = /* @__PURE__ */ re(qr, [["render", Ar], ["__scopeId", "data-v-2d2d343a"]]), Vr = P({
  name: "HeatmapLayer",
  props: {
    options: {
      type: Object,
      default: () => ({})
    }
  },
  setup(n) {
    const e = w(), t = k(D, w()), r = k(Z, w());
    return q(
      [t, () => n.options],
      ([s, o], [i, l]) => {
        const a = !ee(o, l) || t.value !== i;
        if (t.value && r.value && a) {
          let c;
          if (o.data && !(o.data instanceof r.value.MVCArray)) {
            const d = r.value.LatLng, u = o.data.map((h) => h instanceof d || "location" in h && (h.location instanceof d || h.location === null) ? h : "location" in h ? { ...h, location: new d(h.location) } : new d(h));
            c = {
              ...o,
              data: u
            };
          } else
            c = o;
          e.value ? e.value.setOptions(c) : e.value = S(
            new r.value.visualization.HeatmapLayer({
              ...c,
              map: t.value
            })
          );
        }
      },
      { immediate: !0 }
    ), B(() => {
      e.value && e.value.setMap(null);
    }), { heatmapLayer: e };
  },
  render: () => null
});
export {
  jr as AdvancedMarker,
  Dr as Circle,
  Zr as CustomControl,
  Gr as CustomMarker,
  Ir as GoogleMap,
  Vr as HeatmapLayer,
  Fr as InfoWindow,
  Rr as Marker,
  Ur as MarkerCluster,
  Nr as Polygon,
  $r as Polyline,
  Br as Rectangle
};
