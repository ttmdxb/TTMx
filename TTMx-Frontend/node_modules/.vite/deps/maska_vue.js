import "./chunk-V4OQ3NZ2.js";

// node_modules/maska/dist/maska.mjs
var S = Object.defineProperty;
var x = (n, t, e) => t in n ? S(n, t, { enumerable: true, configurable: true, writable: true, value: e }) : n[t] = e;
var A = (n, t, e) => x(n, typeof t != "symbol" ? t + "" : t, e);
var R = {
  "#": { pattern: /[0-9]/ },
  "@": { pattern: /[a-zA-Z]/ },
  "*": { pattern: /[a-zA-Z0-9]/ }
};
var N = (n, t, e) => n.replaceAll(t, "").replace(e, ".").replace("..", ".").replace(/[^.\d]/g, "");
var w = (n, t, e) => {
  var s;
  return new Intl.NumberFormat(((s = e.number) == null ? void 0 : s.locale) ?? "en", {
    minimumFractionDigits: n,
    maximumFractionDigits: t,
    roundingMode: "trunc"
  });
};
var P = (n, t = true, e) => {
  var k2, g, b, d;
  const s = ((k2 = e.number) == null ? void 0 : k2.unsigned) !== true && n.startsWith("-") ? "-" : "", r = ((g = e.number) == null ? void 0 : g.fraction) ?? 0;
  let a = w(0, r, e);
  const u = a.formatToParts(1000.12), p = ((b = u.find((o) => o.type === "group")) == null ? void 0 : b.value) ?? " ", f = ((d = u.find((o) => o.type === "decimal")) == null ? void 0 : d.value) ?? ".", i = N(n, p, f);
  if (Number.isNaN(parseFloat(i))) return s;
  const h = i.split(".");
  if (h[1] != null && h[1].length >= 1) {
    const o = h[1].length <= r ? h[1].length : r;
    a = w(o, r, e);
  }
  let l2 = a.format(parseFloat(i));
  return t ? r > 0 && i.endsWith(".") && !i.slice(0, -1).includes(".") && (l2 += f) : l2 = N(l2, p, f), s + l2;
};
var C = (n) => JSON.parse(n.replaceAll("'", '"'));
var F = (n, t = {}) => {
  const e = { ...t };
  n.dataset.maska != null && n.dataset.maska !== "" && (e.mask = T(n.dataset.maska)), n.dataset.maskaEager != null && (e.eager = E(n.dataset.maskaEager)), n.dataset.maskaReversed != null && (e.reversed = E(n.dataset.maskaReversed)), n.dataset.maskaTokensReplace != null && (e.tokensReplace = E(n.dataset.maskaTokensReplace)), n.dataset.maskaTokens != null && (e.tokens = W(n.dataset.maskaTokens));
  const s = {};
  return n.dataset.maskaNumberLocale != null && (s.locale = n.dataset.maskaNumberLocale), n.dataset.maskaNumberFraction != null && (s.fraction = parseInt(n.dataset.maskaNumberFraction)), n.dataset.maskaNumberUnsigned != null && (s.unsigned = E(n.dataset.maskaNumberUnsigned)), (n.dataset.maskaNumber != null || Object.values(s).length > 0) && (e.number = s), e;
};
var E = (n) => n !== "" ? !!JSON.parse(n) : true;
var T = (n) => n.startsWith("[") && n.endsWith("]") ? C(n) : n;
var W = (n) => {
  if (n.startsWith("{") && n.endsWith("}"))
    return C(n);
  const t = {};
  return n.split("|").forEach((e) => {
    const s = e.split(":");
    t[s[0]] = {
      pattern: I() ? new RegExp(s[1], "u") : new RegExp(s[1]),
      optional: s[2] === "optional",
      multiple: s[2] === "multiple",
      repeated: s[2] === "repeated"
    };
  }), t;
};
var I = () => {
  try {
    return new RegExp("\\p{L}", "u"), true;
  } catch {
    return false;
  }
};
var O = class {
  constructor(t = {}) {
    A(this, "opts", {});
    A(this, "memo", /* @__PURE__ */ new Map());
    const e = { ...t };
    if (e.tokens != null) {
      e.tokens = e.tokensReplace ? { ...e.tokens } : { ...R, ...e.tokens };
      for (const s of Object.values(e.tokens))
        typeof s.pattern == "string" && (s.pattern = I() ? new RegExp(s.pattern, "u") : new RegExp(s.pattern));
    } else
      e.tokens = R;
    Array.isArray(e.mask) && (e.mask.length > 1 ? e.mask = [...e.mask].sort((s, r) => s.length - r.length) : e.mask = e.mask[0] ?? ""), e.mask === "" && (e.mask = null), this.opts = e;
  }
  masked(t) {
    return this.process(String(t), this.findMask(String(t)));
  }
  unmasked(t) {
    return this.process(String(t), this.findMask(String(t)), false);
  }
  isEager() {
    return this.opts.eager === true;
  }
  isReversed() {
    return this.opts.reversed === true;
  }
  completed(t) {
    const e = this.findMask(String(t));
    if (this.opts.mask == null || e == null) return false;
    const s = this.process(String(t), e).length;
    return typeof this.opts.mask == "string" ? s >= this.opts.mask.length : s >= e.length;
  }
  findMask(t) {
    const e = this.opts.mask;
    if (e == null)
      return null;
    if (typeof e == "string")
      return e;
    if (typeof e == "function")
      return e(t);
    const s = this.process(t, e.slice(-1).pop() ?? "", false);
    return e.find((r) => this.process(t, r, false).length >= s.length) ?? "";
  }
  escapeMask(t) {
    const e = [], s = [];
    return t.split("").forEach((r, a) => {
      r === "!" && t[a - 1] !== "!" ? s.push(a - s.length) : e.push(r);
    }), { mask: e.join(""), escaped: s };
  }
  process(t, e, s = true) {
    if (this.opts.number != null) return P(t, s, this.opts);
    if (e == null) return t;
    const r = `v=${t},mr=${e},m=${s ? 1 : 0}`;
    if (this.memo.has(r)) return this.memo.get(r);
    const { mask: a, escaped: u } = this.escapeMask(e), p = [], f = this.opts.tokens != null ? this.opts.tokens : {}, i = this.isReversed() ? -1 : 1, h = this.isReversed() ? "unshift" : "push", l2 = this.isReversed() ? 0 : a.length - 1, k2 = this.isReversed() ? () => o > -1 && c2 > -1 : () => o < a.length && c2 < t.length, g = (v) => !this.isReversed() && v <= l2 || this.isReversed() && v >= l2;
    let b, d = -1, o = this.isReversed() ? a.length - 1 : 0, c2 = this.isReversed() ? t.length - 1 : 0, M = false;
    for (; k2(); ) {
      const v = a.charAt(o), m = f[v], y = (m == null ? void 0 : m.transform) != null ? m.transform(t.charAt(c2)) : t.charAt(c2);
      if (!u.includes(o) && m != null ? (y.match(m.pattern) != null ? (p[h](y), m.repeated ? (d === -1 ? d = o : o === l2 && o !== d && (o = d - i), l2 === d && (o -= i)) : m.multiple && (M = true, o -= i), o += i) : m.multiple ? M && (o += i, c2 -= i, M = false) : y === b ? b = void 0 : m.optional && (o += i, c2 -= i), c2 += i) : (s && !this.isEager() && p[h](v), y === v && !this.isEager() ? c2 += i : b = v, this.isEager() || (o += i)), this.isEager())
        for (; g(o) && (f[a.charAt(o)] == null || u.includes(o)); ) {
          if (s) {
            if (p[h](a.charAt(o)), t.charAt(c2) === a.charAt(o)) {
              o += i, c2 += i;
              continue;
            }
          } else a.charAt(o) === t.charAt(c2) && (c2 += i);
          o += i;
        }
    }
    return this.memo.set(r, p.join("")), this.memo.get(r);
  }
};
var V = class {
  constructor(t, e = {}) {
    A(this, "items", /* @__PURE__ */ new Map());
    A(this, "eventAbortController");
    A(this, "onInput", (t2) => {
      if (t2 instanceof CustomEvent && t2.type === "input" && !t2.isTrusted && !t2.bubbles)
        return;
      const e2 = t2.target, s = this.items.get(e2);
      if (s === void 0) return;
      const r = "inputType" in t2 && t2.inputType.startsWith("delete"), a = s.isEager(), u = r && a && s.unmasked(e2.value) === "" ? "" : e2.value;
      this.fixCursor(e2, r, () => this.setValue(e2, u));
    });
    this.options = e, this.eventAbortController = new AbortController(), this.init(this.getInputs(t));
  }
  update(t = {}) {
    this.options = { ...t }, this.init(Array.from(this.items.keys()));
  }
  updateValue(t) {
    var e;
    t.value !== "" && t.value !== ((e = this.processInput(t)) == null ? void 0 : e.masked) && this.setValue(t, t.value);
  }
  destroy() {
    this.eventAbortController.abort(), this.items.clear();
  }
  init(t) {
    const e = this.getOptions(this.options);
    for (const s of t) {
      if (!this.items.has(s)) {
        const { signal: a } = this.eventAbortController;
        s.addEventListener("input", this.onInput, { capture: true, signal: a });
      }
      const r = new O(F(s, e));
      this.items.set(s, r), queueMicrotask(() => this.updateValue(s)), s.selectionStart === null && r.isEager() && console.warn("Maska: input of `%s` type is not supported", s.type);
    }
  }
  getInputs(t) {
    return typeof t == "string" ? Array.from(document.querySelectorAll(t)) : "length" in t ? Array.from(t) : [t];
  }
  getOptions(t) {
    const { onMaska: e, preProcess: s, postProcess: r, ...a } = t;
    return a;
  }
  fixCursor(t, e, s) {
    var k2, g;
    const r = t.selectionStart, a = t.value;
    if (s(), r === null || r === a.length && !e) return;
    const u = t.value, p = a.slice(0, r), f = u.slice(0, r), i = (k2 = this.processInput(t, p)) == null ? void 0 : k2.unmasked, h = (g = this.processInput(t, f)) == null ? void 0 : g.unmasked;
    if (i === void 0 || h === void 0) return;
    let l2 = r;
    p !== f && (l2 += e ? u.length - a.length : i.length - h.length), t.setSelectionRange(l2, l2);
  }
  setValue(t, e) {
    const s = this.processInput(t, e);
    s !== void 0 && (t.value = s.masked, this.options.onMaska != null && (Array.isArray(this.options.onMaska) ? this.options.onMaska.forEach((r) => r(s)) : this.options.onMaska(s)), t.dispatchEvent(new CustomEvent("maska", { detail: s })), t.dispatchEvent(new CustomEvent("input", { detail: s.masked })));
  }
  processInput(t, e) {
    const s = this.items.get(t);
    if (s === void 0) return;
    let r = e ?? t.value;
    this.options.preProcess != null && (r = this.options.preProcess(r));
    let a = s.masked(r);
    return this.options.postProcess != null && (a = this.options.postProcess(a)), {
      masked: a,
      unmasked: s.unmasked(r),
      completed: s.completed(r)
    };
  }
};

// node_modules/maska/dist/vue.mjs
var l = /* @__PURE__ */ new WeakMap();
var c = (e, s) => {
  if (e.arg == null || e.instance == null) return;
  const a = "setup" in e.instance.$.type;
  e.arg in e.instance ? e.instance[e.arg] = s : a && console.warn("Maska: please expose `%s` using defineExpose", e.arg);
};
var k = (e, s) => {
  var u;
  const a = e instanceof HTMLInputElement ? e : e.querySelector("input");
  if (a == null || (a == null ? void 0 : a.type) === "file") return;
  let t = {};
  if (s.value != null && (t = typeof s.value == "string" ? { mask: s.value } : { ...s.value }), s.arg != null) {
    const o = (r) => {
      const p = s.modifiers.unmasked ? r.unmasked : s.modifiers.completed ? r.completed : r.masked;
      c(s, p);
    };
    t.onMaska = t.onMaska == null ? o : Array.isArray(t.onMaska) ? [...t.onMaska, o] : [t.onMaska, o];
  }
  l.has(a) ? (u = l.get(a)) == null || u.update(t) : l.set(a, new V(a, t));
};
export {
  k as vMaska
};
//# sourceMappingURL=maska_vue.js.map
